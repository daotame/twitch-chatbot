"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EventSubChannelChatBaseNotificationEvent = void 0;
const tslib_1 = require("tslib");
const shared_utils_1 = require("@d-fischer/shared-utils");
const common_1 = require("@twurple/common");
/**
 * An EventSub event representing a notification being sent to a channel's chat.
 */
let EventSubChannelChatBaseNotificationEvent = class EventSubChannelChatBaseNotificationEvent extends common_1.DataObject {
    /** @internal */
    constructor(data, client) {
        super(data);
        this._client = client;
    }
    /**
     * The ID of the broadcaster.
     */
    get broadcasterId() {
        return this[common_1.rawDataSymbol].broadcaster_user_id;
    }
    /**
     * The name of the broadcaster.
     */
    get broadcasterName() {
        return this[common_1.rawDataSymbol].broadcaster_user_login;
    }
    /**
     * The display name of the broadcaster.
     */
    get broadcasterDisplayName() {
        return this[common_1.rawDataSymbol].broadcaster_user_name;
    }
    /**
     * Gets more information about the broadcaster.
     */
    async getBroadcaster() {
        return (0, common_1.checkRelationAssertion)(await this._client.users.getUserById(this[common_1.rawDataSymbol].broadcaster_user_id));
    }
    /**
     * Whether the chatter is anonymous.
     *
     * Only applies to some event types like sub gifts.
     */
    get chatterIsAnonymous() {
        return this[common_1.rawDataSymbol].chatter_is_anonymous;
    }
    /**
     * The ID of the chatter.
     */
    get chatterId() {
        return this[common_1.rawDataSymbol].chatter_user_id;
    }
    /**
     * The name of the chatter.
     */
    get chatterName() {
        return this[common_1.rawDataSymbol].chatter_user_login;
    }
    /**
     * The display name of the chatter.
     */
    get chatterDisplayName() {
        return this[common_1.rawDataSymbol].chatter_user_name;
    }
    /**
     * Gets more information about the chatter.
     */
    async getChatter() {
        return (0, common_1.checkRelationAssertion)(await this._client.users.getUserById(this[common_1.rawDataSymbol].chatter_user_id));
    }
    /**
     * The color of the chatter, or null if they didn't choose a color.
     */
    get color() {
        return this[common_1.rawDataSymbol].color || null;
    }
    /**
     * The badges the chatter has.
     *
     * The returned object contains the badge names as keys and the badge versions as the respective values.
     */
    get badges() {
        return Object.fromEntries(this[common_1.rawDataSymbol].badges.map(badge => [badge.set_id, badge.id]));
    }
    /**
     * Checks whether the chatter has the specified badge.
     *
     * @param name The name of the badge to check.
     */
    hasBadge(name) {
        return this[common_1.rawDataSymbol].badges.some(badge => badge.set_id === name);
    }
    /**
     * Gets the badge info for a specified badge, or null if the badge does not exist.
     *
     * @param name The name of the badge to get info for.
     */
    getBadgeInfo(name) {
        var _a, _b;
        return (_b = (_a = this[common_1.rawDataSymbol].badges.find(badge => badge.set_id === name)) === null || _a === void 0 ? void 0 : _a.info) !== null && _b !== void 0 ? _b : null;
    }
    /**
     * The ID of the notification message.
     */
    get messageId() {
        return this[common_1.rawDataSymbol].message_id;
    }
    /**
     * The text that was sent with the notification, e.g. the resub message or announcement text.
     */
    get messageText() {
        return this[common_1.rawDataSymbol].message.text;
    }
    /**
     * The text that was sent with the notification, structured into pre-parsed parts.
     */
    get messageParts() {
        return this[common_1.rawDataSymbol].message.fragments;
    }
    /**
     * The ID of the broadcaster from whose channel the message was sent.
     *
     * This only applies if a chatter sends a chat message in another channel's chat during a shared chat session.
     * Is `null` when the message notification happens in the same channel as the broadcaster.
     */
    get sourceBroadcasterId() {
        return this[common_1.rawDataSymbol].source_broadcaster_user_id;
    }
    /**
     * The name of the broadcaster from whose channel the message was sent.
     *
     * This only applies if a chatter sends a chat message in another channel's chat during a shared chat session.
     * Is `null` when the message notification happens in the same channel as the broadcaster.
     */
    get sourceBroadcasterName() {
        return this[common_1.rawDataSymbol].source_broadcaster_user_login;
    }
    /**
     * The display name of the broadcaster from whose channel the message was sent.
     *
     * This only applies if a chatter sends a chat message in another channel's chat during a shared chat session.
     * Is `null` when the message notification happens in the same channel as the broadcaster.
     */
    get sourceBroadcasterDisplayName() {
        return this[common_1.rawDataSymbol].source_broadcaster_user_name;
    }
    /**
     * The UUID that identifies the source message from the channel the message was sent.
     *
     * This only applies if a chatter sends a chat message in another channel's chat during a shared chat session.
     * Is `null` when the message happens in the same channel as the broadcaster.
     */
    get sourceMessageId() {
        return this[common_1.rawDataSymbol].source_message_id;
    }
    /**
     * The chat badges for the chatter in the channel the message was sent from.
     *
     * The returned object contains the badge names as keys and the badge versions as the respective values.
     *
     * This only applies if a chatter sends a chat message in another channel's chat during a shared chat session.
     * Is `null` when the message happens in the same channel as the broadcaster.
     */
    get sourceBadges() {
        return this[common_1.rawDataSymbol].source_badges
            ? Object.fromEntries(this[common_1.rawDataSymbol].source_badges.map(badge => [badge.set_id, badge.id]))
            : null;
    }
    /**
     * Checks whether the chatter has the specified badge.
     *
     * This only applies if a chatter sends a chat message to another chat during a shared chat session.
     * Is `null` when the message happens in the same channel as the broadcaster.
     *
     * @param name The name of the badge to check.
     */
    hasSourceBadge(name) {
        return this[common_1.rawDataSymbol].source_badges
            ? this[common_1.rawDataSymbol].source_badges.some(badge => badge.set_id === name)
            : null;
    }
    /**
     * Gets the badge info for a specified badge.
     *
     * This only applies if a chatter sends a chat message in another channel's chat during a shared chat session.
     * Is `null` when the message happens in the same channel as the broadcaster, or if the badge does not exist.
     *
     * @param name The name of the badge to get info for.
     */
    getSourceBadgeInfo(name) {
        var _a, _b, _c;
        return (_c = (_b = (_a = this[common_1.rawDataSymbol].source_badges) === null || _a === void 0 ? void 0 : _a.find(badge => badge.set_id === name)) === null || _b === void 0 ? void 0 : _b.info) !== null && _c !== void 0 ? _c : null;
    }
};
exports.EventSubChannelChatBaseNotificationEvent = EventSubChannelChatBaseNotificationEvent;
tslib_1.__decorate([
    (0, shared_utils_1.Enumerable)(false)
], EventSubChannelChatBaseNotificationEvent.prototype, "_client", void 0);
exports.EventSubChannelChatBaseNotificationEvent = EventSubChannelChatBaseNotificationEvent = tslib_1.__decorate([
    (0, common_1.rtfm)('eventsub-base', 'EventSubChannelChatBaseNotificationEvent', 'broadcasterId')
], EventSubChannelChatBaseNotificationEvent);
